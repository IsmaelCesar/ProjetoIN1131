# -*- coding: utf-8 -*-
"""GA_TSP_Estudo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YW-JUjxrkjuyfLuX2wVpUSjY7EQW57dw
"""

import numpy as np
import random
import statistics
import matplotlib.pyplot as plt

"""**DEFINIÇÃO DO PROBLEMA**"""

#Representação do problema do caixeiro viajante#
#Cidades_Codigo = ['A','B','C','D','E','F','G','H','I','J']
#Cidades = [0,1,2,3,4,5,6,7,8,9]
#X_Coord = [25,1,8,9,4,15,30,11,20,23]
#Y_Coord = [1,8,16,30,9,7,11,25,29,19]

Cidades_Codigo = ['Abreu e Lima','Araçoiaba','Cabo de Santo Agostinho','Camaragibe',
                  'Igarassu','Ilha de Itamaracá','Ipojuca','Itapissuma','Jaboatão dos Guararapes',
                  'Moreno','Olinda','Paulista','Recife','São Lourenço da Mata']
Cidades = [0,1,2,3,4,5,6,7,8,9,10,11,12,13]
X_Coord = [951488.02,931841.18,937345.52,943003.09,952093.07,
           960467.82,933679.41,953048.35,938660.18,929576.04,
           957514.70,955859.31,954449,938503.56]
Y_Coord = [9124112.67,9137218.04,9081735.21,9111087.24,9131426.67,
           9140872.45,9069453.99,9138239.85,9100920.74,9100080.03,
           9111913.35,9119995.54,9108698.82,9113340.75]

Dist = []
for i in range(len(Cidades)):
  aux = []
  for k in range(len(Cidades)):
    aux.append(((X_Coord[i] - X_Coord[k])**2 +(Y_Coord[i] - Y_Coord[k])**2)**1/2)
  Dist.append(aux)

X = X_Coord
Y = Y_Coord

fig = plt.figure(figsize=(6,6))
ax = fig.add_subplot(1, 1, 1, aspect=1)
for i in range(len(Cidades)):
  ax.text(X_Coord[i], Y_Coord[i], Cidades_Codigo[i], fontsize=6, fontweight='bold', color='black', ha='center', va='center')

plt.scatter(X, Y, s=20, c=None)
plt.title("Travelling Salesman Problem", fontsize=14, fontweight='bold')
plt.xlabel('X_Coord')
plt.ylabel('Y_Coord')
plt.show()

#Gero aleatoriamente uma população inicial#
def Initialization(Cidades, pop = 100):
  population = np.empty((0,len(Cidades)))
  for t in range(pop):
    solution = Cidades.copy()
    np.random.shuffle(solution)
    #solution = []
    #for i in range(len(Cidades)):
    #  k = random.choice(s)
    #  solution.append(k)
    #  s.remove(k)
    # solution = np.array(solution)
    population = np.vstack((population,solution))

  return population

#Verifico a função de aptidão de cada uma das soluções nesta população#
def Fitness_Calculation(Population):
  fitness = np.empty((0,len(Cidades)+1))
  for j in range(len(Population)):
    solution = []
    for i in range(len(Population[j])):
      if i+1 in range(len(Population[j])):
        solution.append(Dist[int(Population[j][i])][int(Population[j][i+1])])
      else:
        solution.append(Dist[int(Population[j][i])][int(Population[j][0])])
    solution = -sum(solution) ################# Por ser um problema de minimização, deixo os valores de aptidão negativos para que o menor seja o melhor #################
    aux = [int(i) for i in Population[j]]
    aux.append(solution)
    aux = np.array(aux)
    fitness = np.vstack((fitness,aux))

  return fitness

#Faço um torneio para determinar a escolha dos pais, em que três candidatos são escolhidos aleatoriamente e somente o melhor será vencedor#
def Parent_Selection(Fitness):
  #Faço todo o procedimento para o pai 1#
  candidate_1 = random.randint(0,len(Population)-1)
  candidate_2 = random.randint(0,len(Population)-1)
  candidate_3 = random.randint(0,len(Population)-1)
  while candidate_1 == candidate_2:
    candidate_1 = random.randint(0,len(Population)-1)
  while candidate_2 == candidate_3:
    candidate_3 = random.randint(0,len(Population)-1)
  while candidate_1 == candidate_3:
    candidate_3 = random.randint(0,len(Population)-1)
  fitness_1 = Fitness[candidate_1][-1]
  fitness_2 = Fitness[candidate_2][-1]
  fitness_3 = Fitness[candidate_3][-1]
  parent_1 = Population[candidate_1]
  if fitness_2 >= fitness_1 and fitness_2 >= fitness_3:
    parent_1 = Population[candidate_2]
  if fitness_3 >= fitness_1 and fitness_3 >= fitness_2:
    parent_1 = Population[candidate_3]
  #Em seguida, faço o mesmo para o pai 2#
  candidate_1 = random.randint(0,len(Population)-1)
  candidate_2 = random.randint(0,len(Population)-1)
  candidate_3 = random.randint(0,len(Population)-1)
  while candidate_1 == candidate_2:
    candidate_1 = random.randint(0,len(Population)-1)
  while candidate_2 == candidate_3:
    candidate_3 = random.randint(0,len(Population)-1)
  while candidate_1 == candidate_3:
    candidate_3 = random.randint(0,len(Population)-1)
  fitness_1 = Fitness[candidate_1][-1]
  fitness_2 = Fitness[candidate_2][-1]
  fitness_3 = Fitness[candidate_3][-1]
  parent_2 = Population[candidate_1]
  if fitness_2 >= fitness_1 and fitness_2 >= fitness_3:
    parent_2 = Population[candidate_2]
  if fitness_3 >= fitness_1 and fitness_3 >= fitness_2:
    parent_2 = Population[candidate_3]

  return parent_1, parent_2

#Como operador de recombinação, faço um cruzamento de ordem entre os dois pais; incluo uma probabilidade padrão de 85%#
def Cross_over(Parent_1, Parent_2, prob = 0.85):
  probability = random.random()
  #Faço primeiro a determinação dos genes de referência para o cruzamento#
  if probability < prob:
    Child_1 = [None] * len(Parent_1)
    gene_1 = random.randint(0,len(Parent_1))
    gene_2 = random.randint(0,len(Parent_1))
    while gene_2 == gene_1:
      gene_2 = random.randint(0,len(Parent_1))
    if gene_2 < gene_1:
      aux = gene_2
      gene_2 = gene_1
      gene_1 = aux
  #Faço todo o procedimento para a criança 1#
    for i in range(gene_1, gene_2):
      Child_1[i] = Parent_1[i]
    if gene_2 < len(Child_1):
      temp_gene_2 = gene_2 #Esse gene temporário existe somente para evitar que haja uma sobreposição de alelos já selecionados#
      for i in range(gene_2,len(Child_1)):
        for k in range(gene_2,len(Parent_2)):
          aux = Parent_2[k]
          if aux not in Child_1 and Child_1[i] == None:
            Child_1[i] = aux
            temp_gene_2 += 1
            break
      for i in range(temp_gene_2,len(Child_1)):
        for k in range(gene_2):
          aux = Parent_2[k]
          if aux not in Child_1:
            Child_1[i] = aux
            break
    if None in Child_1:
      for i in range(gene_1):
        for k in range(len(Parent_2)):
          aux = Parent_2[k]
          if aux not in Child_1:
            Child_1[i] = aux
            break

  #Em seguida, faço o mesmo para a criança 2, só não preciso mexer nos genes novamente#
    Child_2 = [None] * len(Parent_2)
    for i in range(gene_1, gene_2):
      Child_2[i] = Parent_2[i]
    if gene_2 < len(Child_2):
      temp_gene_2 = gene_2 #Novamente, esse gene temporário existe somente para evitar que haja uma sobreposição de alelos já selecionados#
      for i in range(gene_2,len(Child_2)):
        for k in range(gene_2,len(Parent_1)):
          aux = Parent_1[k]
          if aux not in Child_2 and Child_2[i] == None:
            Child_2[i] = aux
            temp_gene_2 += 1
            break
      for i in range(temp_gene_2,len(Child_2)):
        for k in range(gene_2):
          aux = Parent_1[k]
          if aux not in Child_2:
            Child_2[i] = aux
            break
    if None in Child_2:
      for i in range(gene_1):
        for k in range(len(Parent_1)):
          aux = Parent_1[k]
          if aux not in Child_2:
            Child_2[i] = aux
            break
  else:
    Child_1 = Parent_1.copy()
    Child_2 = Parent_2.copy()

  return Child_1, Child_2

#Como operador de mutação, faço um simples procedimento de troca (swap) entre dois genes; incluo uma probabilidade padrão de 10%#
def Mutation(Child_1, Child_2, prob = 0.1):
  #Faço todo o procedimento para a criança mutada 1#
  probability = random.random()
  if probability < prob:
    mutated_child_1 = Child_1.copy()
    mutated_child_2 = Child_2.copy()
    gene_1 = random.randint(0,len(Child_1)-1)
    gene_2 = random.randint(0,len(Child_1)-1)
    while gene_1 == gene_2:
      gene_2 = random.randint(0,len(Child_1)-1)
    aux1 = mutated_child_1[gene_2]
    aux2 = mutated_child_2[gene_2]
    mutated_child_1[gene_2] = mutated_child_1[gene_1]
    mutated_child_1[gene_1] = aux1
    mutated_child_2[gene_2] = mutated_child_2[gene_1]
    mutated_child_2[gene_1] = aux2
  else:
    mutated_child_1 = Child_1.copy()
    mutated_child_2 = Child_2.copy()

  return mutated_child_1, mutated_child_2

#############################################################################################################################################################################
######################## Esta célula é meramente um teste, para que se veja que o crossover e a mutação funcionam da maneira que foram implementados ########################
#############################################################################################################################################################################
#Inicio a população e computo os valores de aptidão de cada indivíduo#
Population = Initialization(Cidades, pop=30)
Fitness = Fitness_Calculation(Population)
Parent_1, Parent_2 = Parent_Selection(Fitness)
print(Parent_1)
print(Parent_2)
Child_1, Child_2 = Cross_over(Parent_1, Parent_2)
Mutated_Child_1, Mutated_Child_2 = Mutation(Child_1, Child_2)
print(Child_1)
print(Child_2)
print(Mutated_Child_1)
print(Mutated_Child_2)

#Crio ainda uma função elitista, para garantir que sempre a melhor solução da geração anterior permaneça na nova geração#
#Esta solução de elite substituirá a pior solução da nova geração, mas fora isso, toda a nova geração será composta por novos indivíduos#
def Elitism(old_sorted_population, new_sorted_population):
  Elite = old_sorted_population[0]
  new_population_elitism = new_sorted_population.copy()
  new_population_elitism[-1] = Elite
  new_population_elitism = np.array(sorted(new_population_elitism, reverse=True, key=lambda x:x[-1]))

  return new_population_elitism

"""**RESOLUÇÃO DO PROBLEMA EM UMA ÚNICA RODADA**"""

#############################################################################################################################################################################
####################################################### Nesta célula eu de fato executo meu algoritmo evolucionário ########################################################
#############################################################################################################################################################################
Population = Initialization(Cidades, pop=200)
Fitness = Fitness_Calculation(Population)
Sorted_Population = np.array(sorted(Fitness, reverse=True, key=lambda x:x[-1]))

Best_of_Generation, Average_of_Generation = [], []
Best_Overall = Fitness[random.randint(0,len(Fitness)-1)]

for major_it in range(int(len(Population))):
  New_Population = np.empty((0,len(Cidades)))
  for minor_it in range(int(len(Population)/2)):
    Parent_1, Parent_2 = Parent_Selection(Fitness)
    Child_1, Child_2 = Cross_over(Parent_1, Parent_2)
    Mutated_Child_1, Mutated_Child_2 = Mutation(Child_1, Child_2)
    Mutated_Child_1 = np.array(Mutated_Child_1)
    Mutated_Child_2 = np.array(Mutated_Child_2)
    New_Population = np.vstack((New_Population,Mutated_Child_1))
    New_Population = np.vstack((New_Population,Mutated_Child_2))
  New_Fitness = Fitness_Calculation(New_Population)
  Sorted_New_Population = np.array(sorted(New_Fitness, reverse=True, key=lambda x:x[-1]))
  Sorted_New_Population_Elitism = Elitism(Sorted_Population, Sorted_New_Population)

  Average_of_Generation.append(statistics.mean([Sorted_New_Population[i][-1] for i in range(len(Sorted_New_Population))]))
  Best_of_Generation.append(Sorted_New_Population_Elitism[0])
  if Best_of_Generation[major_it][-1] > Best_Overall[-1]:
    Best_Overall = Best_of_Generation[major_it].copy()

  Fitness = Sorted_New_Population_Elitism.copy()
  Sorted_Population = np.array(sorted(Fitness, reverse=True, key=lambda x:x[-1]))
  print('Generation {}, Best_Overall_Solution {}'.format(major_it+1,Best_Overall[-1]))

Plot_Average = [-Average_of_Generation[i] for i in range(len(Average_of_Generation))]
Plot_Best = [-Best_of_Generation[i][-1] for i in range(len(Best_of_Generation))]

plt.plot(Plot_Average, color='gray')
plt.plot(Plot_Best, color='blue')
plt.xlabel('Generations')
plt.ylabel('Objective_Function')
plt.show()

Plot_Cycle = [Best_Overall[i] for i in range(len(Best_Overall) -1)]
Plot_X, Plot_Y, Plot_Codigos = [], [], []
for i in Plot_Cycle:
  Plot_X.append(X_Coord[int(i)])
  Plot_Y.append(Y_Coord[int(i)])
  Plot_Codigos.append(Cidades_Codigo[int(i)])

Plot_X.append(Plot_X[0])
Plot_Y.append(Plot_Y[0])
Plot_Codigos.append(Plot_Codigos[0])
Plot_Cycle.append(Plot_Cycle[0])

fig = plt.figure(figsize=(8,20))
ax = fig.add_subplot(1, 1, 1, aspect=1)
for i in range(len(Plot_Cycle)):
  ax.text(Plot_X[i], Plot_Y[i], Plot_Codigos[i], fontsize=6, fontweight='bold', color='black', ha='center', va='center')

plt.scatter(Plot_X, Plot_Y, s=20, c=None)
plt.plot(Plot_X, Plot_Y)
plt.title("Travelling Salesman Problem Optimized", fontsize=14, fontweight='bold')
plt.xlabel('X_Coord')
plt.ylabel('Y_Coord')
plt.show()

"""**RESOLUÇÃO DO PROBLEMA EM MÚLTIPLAS RODADAS**"""

#############################################################################################################################################################################
####################################################### Nesta célula eu de fato executo meu algoritmo evolucionário ########################################################
#############################################################################################################################################################################
Best_per_turn = []
for rodada in range(30):
  Population = Initialization(Cidades, pop=100)
  Fitness = Fitness_Calculation(Population)
  Sorted_Population = np.array(sorted(Fitness, reverse=True, key=lambda x:x[-1]))
  Best_of_Generation, Average_of_Generation = [], []
  Best_Overall = Fitness[random.randint(0,len(Fitness)-1)]
  for major_it in range(int(len(Population))):
    New_Population = np.empty((0,len(Cidades)))
    for minor_it in range(int(len(Population)/2)):
      Parent_1, Parent_2 = Parent_Selection(Fitness)
      Child_1, Child_2 = Cross_over(Parent_1, Parent_2)
      Mutated_Child_1, Mutated_Child_2 = Mutation(Child_1, Child_2)
      Mutated_Child_1 = np.array(Mutated_Child_1)
      Mutated_Child_2 = np.array(Mutated_Child_2)
      New_Population = np.vstack((New_Population,Mutated_Child_1))
      New_Population = np.vstack((New_Population,Mutated_Child_2))
    New_Fitness = Fitness_Calculation(New_Population)
    Sorted_New_Population = np.array(sorted(New_Fitness, reverse=True, key=lambda x:x[-1]))
    Sorted_New_Population_Elitism = Elitism(Sorted_Population, Sorted_New_Population)

    Average_of_Generation.append(statistics.mean([Sorted_New_Population[i][-1] for i in range(len(Sorted_New_Population))]))
    Best_of_Generation.append(Sorted_New_Population_Elitism[0])
    if Best_of_Generation[major_it][-1] > Best_Overall[-1]:
      Best_Overall = Best_of_Generation[major_it].copy()

    Fitness = Sorted_New_Population_Elitism.copy()
    Sorted_Population = np.array(sorted(Fitness, reverse=True, key=lambda x:x[-1]))
  Best_per_turn.append(Best_Overall)
  print('Turn {}, Best_Overall_Solution_per_Turn {}'.format(rodada+1,Best_per_turn[rodada][-1]))

Best_per_turn





###################################################################### Friedman Test ######################################################################
from scipy.stats import friedmanchisquare
before = [72, 96, 88, 92, 74, 76, 82]
immediately_after = [120, 120, 132, 120, 101, 96, 112]
five_min_after = [76, 95, 104, 96, 84, 72, 76]
res = friedmanchisquare(before, immediately_after, five_min_after)
res.statistic
10.57142857142857
res.pvalue
0.005063414171757498